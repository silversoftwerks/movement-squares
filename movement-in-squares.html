<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movement in Squares - Interactive</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }
        
        label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        .value-display {
            font-size: 0.8em;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        
        .info {
            margin-top: 30px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .animation-controls {
            background-color: #f0f8ff;
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-top: 10px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .animation-params {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <h1>Movement in Squares - Interactive</h1>
    
    <div class="controls">
        <div class="control-group">
            <label for="gridSize">Grid Size</label>
            <input type="range" id="gridSize" min="5" max="40" value="20">
            <div class="value-display" id="gridSizeValue">20 × 20</div>
        </div>
        
        <div class="control-group">
            <label for="distortionFactor">Distortion Factor</label>
            <input type="range" id="distortionFactor" min="0" max="100" value="80">
            <div class="value-display" id="distortionFactorValue">80%</div>
        </div>
        
        <div class="control-group">
            <label for="distortionCenter">Distortion Center</label>
            <input type="range" id="distortionCenter" min="0" max="100" value="50">
            <div class="value-display" id="distortionCenterValue">50%</div>
        </div>
        
        <div class="control-group">
            <label for="distortionExponent">Distortion Curve</label>
            <input type="range" id="distortionExponent" min="1" max="5" value="2" step="0.1">
            <div class="value-display" id="distortionExponentValue">2.0</div>
        </div>
    </div>
    
    <div class="animation-controls">
        <div class="control-group">
            <label for="movementType">Distortion Movement</label>
            <select id="movementType">
                <option value="static">Static (No Movement)</option>
                <option value="random">Random Walk</option>
                <option value="sine">Sine Wave</option>
                <option value="triangle">Triangle Wave</option>
                <option value="square">Square Wave</option>
                <option value="audio">Audio Visualizer</option>
            </select>
        </div>
        
        <div class="animation-params">
            <div class="control-group">
                <label for="movementSpeed">Movement Speed</label>
                <input type="range" id="movementSpeed" min="1" max="100" value="30">
                <div class="value-display" id="movementSpeedValue">30%</div>
            </div>
            
            <div class="control-group">
                <label for="movementRange">Movement Range</label>
                <input type="range" id="movementRange" min="1" max="100" value="50">
                <div class="value-display" id="movementRangeValue">50%</div>
            </div>
        </div>
        
        <button id="startAudio">Start Audio Visualizer</button>
        <button id="stopAnimation">Stop Movement</button>
    </div>
    
    <canvas id="canvas" width="800" height="800"></canvas>
    
    <div class="info">
        <p>This is an interactive recreation of Bridget Riley's "Movement in Squares" (1961), a famous op art piece. The original artwork creates an illusion of movement through the gradual distortion of a grid of black and white squares.</p>
        <p>Use the sliders above to adjust various parameters and create your own version of this iconic piece. You can also enable dynamic movement of the distortion center using different patterns or audio input.</p>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Get all controls
        const gridSizeControl = document.getElementById('gridSize');
        const distortionFactorControl = document.getElementById('distortionFactor');
        const distortionCenterControl = document.getElementById('distortionCenter');
        const distortionExponentControl = document.getElementById('distortionExponent');
        const movementTypeSelect = document.getElementById('movementType');
        const movementSpeedControl = document.getElementById('movementSpeed');
        const movementRangeControl = document.getElementById('movementRange');
        const startAudioButton = document.getElementById('startAudio');
        const stopAnimationButton = document.getElementById('stopAnimation');
        
        // Get all value displays
        const gridSizeValue = document.getElementById('gridSizeValue');
        const distortionFactorValue = document.getElementById('distortionFactorValue');
        const distortionCenterValue = document.getElementById('distortionCenterValue');
        const distortionExponentValue = document.getElementById('distortionExponentValue');
        const movementSpeedValue = document.getElementById('movementSpeedValue');
        const movementRangeValue = document.getElementById('movementRangeValue');
        
        // Animation variables
        let animationFrameId = null;
        let lastTimestamp = 0;
        let currentDistortionCenter = 0.5; // Start at 50%
        let randomWalkVelocity = 0;
        let oscillatorPhase = 0;
        let audioContext = null;
        let audioAnalyser = null;
        let audioDataArray = null;
        let audioSource = null;
        
        // Function to update value displays
        function updateValueDisplays() {
            const gridSize = parseInt(gridSizeControl.value);
            gridSizeValue.textContent = `${gridSize} × ${gridSize}`;
            
            const distortionFactor = parseInt(distortionFactorControl.value);
            distortionFactorValue.textContent = `${distortionFactor}%`;
            
            const distortionCenter = parseInt(distortionCenterControl.value);
            distortionCenterValue.textContent = `${distortionCenter}%`;
            
            const distortionExponent = parseFloat(distortionExponentControl.value);
            distortionExponentValue.textContent = distortionExponent.toFixed(1);
            
            const movementSpeed = parseInt(movementSpeedControl.value);
            movementSpeedValue.textContent = `${movementSpeed}%`;
            
            const movementRange = parseInt(movementRangeControl.value);
            movementRangeValue.textContent = `${movementRange}%`;
        }
        
        // Gaussian-like curve function
        function gaussianCurve(x, sigma = 0.3) {
            return Math.exp(-(x * x) / (2 * sigma * sigma));
        }
        
        // Function to draw the artwork
        function drawMovementInSquares(dynamicDistortionCenter = null) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get parameter values
            const gridSize = parseInt(gridSizeControl.value);
            const distortionFactor = parseInt(distortionFactorControl.value) / 100;
            const distortionExponent = parseFloat(distortionExponentControl.value);
            
            // Use dynamic distortion center if provided, otherwise use the slider value
            const distortionCenter = dynamicDistortionCenter !== null ? 
                dynamicDistortionCenter : parseInt(distortionCenterControl.value) / 100;
            
            // Calculate cell size
            const cellSize = canvas.width / gridSize;
            
            // Draw black background first to ensure full coverage
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Pre-calculate the positions of all grid points with distortion
            const positions = [];
            
            // Add extra columns on each side to overflow
            const extraColumns = Math.ceil(gridSize * 0.2); // 20% more squares on each side
            const totalColumns = gridSize + (extraColumns * 2);
            
            // Calculate the distorted x positions for each column, including overflow
            for (let x = -extraColumns; x <= gridSize + extraColumns; x++) {
                // Calculate normalized position (0 to 1)
                const normalizedX = x / gridSize;
                
                // Distance from center (0 to 1)
                const distanceFromCenter = Math.abs(normalizedX - distortionCenter);
                
                // Direction multiplier (-1 for left of center, 1 for right)
                const direction = Math.sign(normalizedX - distortionCenter);
                
                // Base undistorted position
                let transformedX = normalizedX;
                
                // Apply distortion only if not at exact center
                if (distanceFromCenter > 0) {
                    // Use Gaussian curve for smoother compression near the center
                    const gaussianFactor = gaussianCurve(distanceFromCenter, 0.4);
                    
                    // Combine with power curve for edge behavior
                    const powerFactor = Math.pow(1 - distanceFromCenter, distortionExponent);
                    
                    // Blend both curves for a more rounded effect
                    const compressionStrength = (gaussianFactor * 0.7 + powerFactor * 0.3) * distortionFactor;
                    
                    // Apply compression toward center with enhanced curve
                    if (direction < 0) {
                        transformedX = normalizedX + (distanceFromCenter * compressionStrength);
                    } else {
                        transformedX = normalizedX - (distanceFromCenter * compressionStrength);
                    }
                }
                
                // Convert normalized position to canvas coordinates
                const position = transformedX * canvas.width;
                positions.push(position);
            }
            
            // Draw the grid - white squares only (black background already drawn)
            for (let x = 0; x < positions.length - 1; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const x1 = positions[x];
                    const x2 = positions[x + 1];
                    const y1 = y * cellSize;
                    const y2 = (y + 1) * cellSize;
                    
                    const width = x2 - x1;
                    
                    // Draw only white squares over black background
                    // Adjust the checkerboard pattern for the extra columns
                    if (((x + extraColumns) + y) % 2 !== 0) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(x1, y1, width, cellSize);
                    }
                }
            }
        }
        
        // Function to update movement based on the selected mode
        function updateMovement(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;
            
            const movementType = movementTypeSelect.value;
            const movementSpeed = parseInt(movementSpeedControl.value) / 100 * 2;
            const movementRange = parseInt(movementRangeControl.value) / 100;
            
            // Maximum range is 0.5 on each side of the center (0.5)
            const maxRange = 0.5 * movementRange;
            const centerPoint = 0.5;
            
            // Update based on movement type
            switch(movementType) {
                case 'random':
                    // Random walk with inertia
                    const randomAcceleration = (Math.random() - 0.5) * movementSpeed * 5;
                    randomWalkVelocity += randomAcceleration * deltaTime;
                    randomWalkVelocity *= 0.95; // Damping
                    
                    currentDistortionCenter += randomWalkVelocity * deltaTime;
                    
                    // Bounce off boundaries
                    if (currentDistortionCenter < centerPoint - maxRange || 
                        currentDistortionCenter > centerPoint + maxRange) {
                        randomWalkVelocity = -randomWalkVelocity * 0.8;
                        currentDistortionCenter = Math.max(centerPoint - maxRange, 
                                                  Math.min(centerPoint + maxRange, currentDistortionCenter));
                    }
                    break;
                    
                case 'sine':
                    // Sine wave oscillator
                    oscillatorPhase += deltaTime * movementSpeed;
                    currentDistortionCenter = centerPoint + Math.sin(oscillatorPhase) * maxRange;
                    break;
                    
                case 'triangle':
                    // Triangle wave oscillator
                    oscillatorPhase += deltaTime * movementSpeed;
                    const trianglePhase = (oscillatorPhase % (2 * Math.PI)) / (2 * Math.PI);
                    const triangleValue = trianglePhase < 0.5 ? 
                        (4 * trianglePhase - 1) : (3 - 4 * trianglePhase);
                    currentDistortionCenter = centerPoint + triangleValue * maxRange;
                    break;
                    
                case 'square':
                    // Square wave oscillator
                    oscillatorPhase += deltaTime * movementSpeed;
                    const squareValue = Math.sin(oscillatorPhase) >= 0 ? 1 : -1;
                    currentDistortionCenter = centerPoint + squareValue * maxRange;
                    break;
                    
                case 'audio':
                    // Audio visualizer
                    if (audioAnalyser) {
                        audioAnalyser.getByteFrequencyData(audioDataArray);
                        
                        // Use average of bass frequencies for movement
                        let bassAverage = 0;
                        const bassSamples = Math.min(20, audioDataArray.length / 8);
                        for (let i = 0; i < bassSamples; i++) {
                            bassAverage += audioDataArray[i];
                        }
                        bassAverage /= bassSamples;
                        
                        // Map the bass average (0-255) to distortion center
                        const normalizedBass = bassAverage / 255;
                        currentDistortionCenter = centerPoint + (normalizedBass * 2 - 1) * maxRange;
                    }
                    break;
                    
                case 'static':
                default:
                    // Static position from slider
                    currentDistortionCenter = parseInt(distortionCenterControl.value) / 100;
                    break;
            }
            
            // Draw with the updated distortion center
            drawMovementInSquares(currentDistortionCenter);
            
            // Continue animation loop
            if (movementType !== 'static') {
                animationFrameId = requestAnimationFrame(updateMovement);
            }
        }
        
        // Function to start animation
        function startAnimation() {
            // Stop any existing animation
            stopAnimation();
            
            // Reset animation variables
            lastTimestamp = 0;
            
            // Start the new animation loop
            animationFrameId = requestAnimationFrame(updateMovement);
        }
        
        // Function to stop animation
        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Return to static rendering with slider value
            drawMovementInSquares();
        }
        
        // Function to initialize audio context
        async function initAudio() {
            try {
                // Create audio context if needed
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioAnalyser = audioContext.createAnalyser();
                    audioAnalyser.fftSize = 256;
                    const bufferLength = audioAnalyser.frequencyBinCount;
                    audioDataArray = new Uint8Array(bufferLength);
                }
                
                // Get user media
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Stop any existing audio source
                if (audioSource) {
                    audioSource.disconnect();
                }
                
                // Create new audio source
                audioSource = audioContext.createMediaStreamSource(stream);
                audioSource.connect(audioAnalyser);
                
                // Set movement type to audio
                movementTypeSelect.value = 'audio';
                
                // Start animation
                startAnimation();
                
            } catch (error) {
                console.error('Error accessing microphone:', error);
                alert('Could not access microphone. Audio visualizer requires microphone permission.');
            }
        }
        
        // Add event listeners
        gridSizeControl.addEventListener('input', () => {
            updateValueDisplays();
            drawMovementInSquares();
        });
        
        distortionFactorControl.addEventListener('input', () => {
            updateValueDisplays();
            drawMovementInSquares();
        });
        
        distortionCenterControl.addEventListener('input', () => {
            updateValueDisplays();
            drawMovementInSquares();
            currentDistortionCenter = parseInt(distortionCenterControl.value) / 100;
        });
        
        distortionExponentControl.addEventListener('input', () => {
            updateValueDisplays();
            drawMovementInSquares();
        });
        
        movementSpeedControl.addEventListener('input', updateValueDisplays);
        movementRangeControl.addEventListener('input', updateValueDisplays);
        
        movementTypeSelect.addEventListener('change', () => {
            if (movementTypeSelect.value !== 'static') {
                startAnimation();
            } else {
                stopAnimation();
            }
        });
        
        startAudioButton.addEventListener('click', initAudio);
        stopAnimationButton.addEventListener('click', () => {
            movementTypeSelect.value = 'static';
            stopAnimation();
        });
        
        // Initial draw
        updateValueDisplays();
        drawMovementInSquares();
    </script>
</body>
</html> 